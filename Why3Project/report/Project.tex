% Header
\documentclass[a4paper]{article}%      autres choix : book, report
\usepackage[utf8]{inputenc}%           gestion des accents (source)
\usepackage[T1]{fontenc}%              gestion des accents (PDF)
\usepackage[francais]{babel}%          gestion du français
\usepackage{textcomp}%                 caractères additionnels
\usepackage{mathtools,amssymb,amsthm}% packages de l'AMS + mathtools
\usepackage{lmodern}%                  police de caractère
\usepackage[top=2cm,left=2cm,right=2cm,bottom=2cm]{geometry}%     gestion des marges
\usepackage{graphicx}%                 gestion des images
\usepackage{array}%                    gestion améliorée des tableaux
\usepackage{calc}%                     syntaxe naturelle pour les calculs
\usepackage{titlesec}%                 pour les sections
\usepackage{titletoc}%                 pour la table des matières
\usepackage{fancyhdr}%                 pour les en-têtes
\usepackage{titling}%                  pour le titre
\usepackage{enumitem}%                 pour les listes numérotées
\usepackage{hyperref}%                 gestion des hyperliens
\usepackage{minted}
\usemintedstyle{vs}

\hypersetup{pdfstartview=XYZ}%         zoom par défaut

\setlength{\droptitle}{-5em}   % This is your set screw
\title{\vspace{1.5cm}Projet Why3}
\author{Mickaël LAURENT}
\date{\vspace{-5ex}}

\pagenumbering{gobble}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\begin{document}

	\maketitle

	\section{Implémentation et preuves}

	\paragraph{0. axioms}
	Je n'ai eu besoin que de l'axiome supplémentaire proposé dans le sujet:
	\[\forall xy, 0 < x < y \implies log(x) < log(y)\]

	\paragraph{1. power2}
	J'avais initialement implémenté cette fonction de manière itérative (code toujours présent mais commenté),
	mais j'ai finalement opté pour une version récursive, à la fois plus concise à implémenter et à prouver.
	En effet, la bibliothèque standard définie elle-même power de manière récursive, rendant la preuve de mon implémentation immédiate.
	Il a seulement été nécessaire d'indiquer le variant: l'argument $l$ en entrée de la fonction.

	\paragraph{2. shift\_left}
	J'ai opté pour l'implémentation suivante:  \mintinline{ocaml}{z * (power2 l)}.\\
	Elle traduit littéralement la spécification de la fonction: \mintinline{ocaml}{result = z * (power 2 l)}.

	\paragraph{3. ediv\_mod}
	Mon implémentation est itérative et utilise la méthode d'euclide, comme celle faite en exercice durant l'année.
	En revanche, ici $x$ peut être négatif, ainsi j'utilise deux implémentations différentes selon le cas:
	si $x \geq 0$ alors je commence avec un reste $r$ positif auquel je soustrait $y$ à chaque itération, sinon, si $x < 0$,
	je commence avec un $r$ négatif auquel j'ajoute $y$ à chaque itération.\\
	La terminaison se prouve facilement en spécifiant le variant: $r$ dans un cas, $-r$ dans l'autre.\\
	La correction se prouve également sans difficulté en utilisant l'invariant adéquate, par exemple pour le cas $x < 0$:
	\mintinline{ocaml}{x = !q * y + !r /\ !r < y}.

	\paragraph{4. shift\_right}
	J'utilise l'implémentation suivante: \mintinline{ocaml}{let d,_ = ediv_mod z (power2 l) in d},
	qui traduit directement la spécification voulue: \mintinline{ocaml}{result = ED.div z (power 2 l)}.
	
	\paragraph{5. isqrt}
	Là encore j'utilise l'implémentation itérative vue en cours:
	\begin{minted}{ocaml}
let count = ref 0 in
let sum = ref 1 in
while !sum <= n do
	invariant { 0 <= !count /\ !count * !count <= n /\ !sum = (!count+1)*(!count+1) }
	variant { n - !sum }
	count := !count + 1;
	sum := !sum + 2 * !count + 1
done ; !count
	\end{minted}
	La terminaison est immédiate étant donné le variant,
	mais la correction (\mintinline{ocaml}{result = floor (sqrt (from_int n))}) nécessite tout de même
	de spécifier quelques trivialités après la boucle while (voir dans le code).\\

	NOTE: je n'ai pas eu besoin du lemme suggéré (euclid\_uniq) pour les 5 questions précédentes.

	\paragraph{6-12. some properties} La quasi-totalité des propriétés de l'énoncé ont été prouvées
	immédiatement par Z3, excepté \mintinline{ocaml}{_B_9} et \mintinline{ocaml}{_B_11} qui ont
	nécessité une étape intermédiaire (lemmes \mintinline{ocaml}{_B_9_aux} et \mintinline{ocaml}{_B_11_aux}).
	\begin{minted}{ocaml}
lemma _B_6 : forall n. _B n >. 0.
lemma _B_7 : forall n, m. (_B n) *. (_B m) = _B (n + m)
lemma _B_8 : forall n. _B n *. _B (-n) = 1.
lemma _B_9_aux : forall n. sqrt (_B (2*n)) = _B n
lemma _B_9 : forall a,n. 0. <=. a -> sqrt (a *. _B (2*n)) = (sqrt a) *. (_B n)
lemma _B_10 : forall y. 0 <= y -> _B y = from_int (power 4 y)
lemma _B_11_aux : forall y. (pow b y)*.(pow b (-.y)) = 1. (* Same as B_8 but for reals *)
lemma _B_11 : forall y. y < 0 -> _B y = inv (from_int (power 4 (-y)))
lemma _B_12 : forall y. 0 <= y -> power 2 (2 * y) = power 4 y
	\end{minted}

	\paragraph{13. framing} La définition de l'énoncé est meilleure que $|x - p(B^{-n})| < B^{-n}$ car elle
	est divisée en deux inégalités plus simples que l'on peut prouver séparemment.
	Ces deux inégalités auraient de toute façon dû être prouvées avant de pouvoir prouver $|x - p(B^{-n})| < B^{-n}$
	car une disjonction de cas est requise par la valeur absolue.

	\paragraph{14. addition} La preuve compliquée ici est \mintinline{ocaml}{compute_round}.
	Il faut montrer \mintinline{ocaml}{framing z result n}. J'ai choisi de montrer les deux inégalités
	correspondantes séparemment (les preuves sont similaires, mais je trouvais cela trop chargé de tout faire
	en une seule fois). Pour chaque inégalité, on part de l'encadrement de \mintinline{ocaml}{round_z_over_4 zp}
	(assuré par la spécification de denière fonction), on multiple par $B^{-n}$ des deux cotés et on simplifie
	jusqu'à obtenir l'encadrement voulu:
	\begin{minted}{ocaml}
assert { (from_int res) <=. ((from_int zp +. 2.) *. _B (-1)) } ;
assert { (from_int res) *. (_B (-n)) <=. ((from_int zp +. 2.) *. _B (-1)) *. (_B (-n)) } ;
...
assert { (from_int res) *. (_B (-n)) <=. lb +. (_B (-n)) } ;
assert { (from_int res -. 1.) *. (_B (-n)) <=. lb } ;
	\end{minted}

	\paragraph{15. compute\_neg} Aucune difficulté ici, on obtient un encadrement valide de $-x$ simplement
	en prenant la négation d'un l'encadrement de $x$ de même précision.

	\paragraph{16. compute\_sub} Aucune difficulté non plus, la soustraction de $x$ par $y$
	étant équivalente à l'addition de $x$ et de l'opposé de $y$. Il faut simplement faire attention à
	demander un encadrement de $x$ et $y$ de précision $n+1$, car l'addition fait perdre un niveau de précision.

	\paragraph{16,5. compute\_cst} Il n'y a pas vraiment de question pour cette fonction dans l'énoncé,
	mais la preuve de la fonction fournie n'est pas immédiate pour autant.
	Le cas $n=0$ ne pose aucune difficulté, mais les cas $n<0$ et $n>0$ nécessitent quelques étapes intermédiaires.
	J'ai encore une fois prouvé chaque inégalité de l'encadrement séparemment. Il n'y a pas de difficulté mathématique
	pour ces inégalités, chacune se simplifie immédiatement en une inégalité triviale.

	\paragraph{17. boundaries for sqrt} Pour prouver l'encadrement de l'énoncé, j'ai commencé par prouver un lemme plus simple:
	$\sqrt{n+1}-\sqrt{n}\leq 1$. Il se prouve facilement en montrant que $(\sqrt{n+1}-\sqrt{n})^2\leq 1$.
	A partir de ce lemme, la preuve de $\floor*{\sqrt{n}} \leq \floor*{\sqrt{n-1}}+1$ est immédiate.\\
	En revanche, la preuve de $\ceil*{\sqrt{n+1}}-1 \leq \floor*{\sqrt{n}}$ est un peu plus astucieuse.
	J'ai séparé la preuve en deux cas, selon que $n+1$ soit un carré parfait ou non. Dans le premier cas,
	on peut conclure directement grace au lemme et au fait que $\ceil*{\sqrt{n+1}}=\sqrt{n+1}$.
	Dans le second cas, on peut montrer par l'absurde que $\floor*{\sqrt{n+1}}\leq \floor*{\sqrt{n}}$
	($\floor*{\sqrt{n+1}} > \floor*{\sqrt{n}} \implies n < (\floor*{\sqrt{n+1}})^2 < n+1$),
	puis conclure sans difficulté.

	\paragraph{18. compute\_sqrt} Bien qu'il m'ai fallu plusieurs étapes intermédiaires, cette preuve est relativement
	facile. Pour le case du \mintinline{ocaml}{else}, on part de l'encadrement initial de x, on passe à la racine et on se sert du résultat
	précédent pour obtenir l'encadrement voulu (on peut temporairement multiplier le tout par $B^n$ pour pouvoir appliquer plus
	facilement le résultat précédent).

	\paragraph{19. interp} Aucune difficulté pour cette fonction. Il faut simplement bien penser à la déclarer \mintinline{ocaml}{ghost},
	car les opérations sur les réels ne sont pas calculables.

	\paragraph{20. wf\_term} Le seul cas intéressant ici est le cas de la racine. Pour ce cas il faut vérifier que l'interpretation
	de l'argument est positif ET qu'il est un terme valide (le fait que le terme en argument ait une intrepretation positive
	n'implique pas qu'il soit valide).
	\begin{minted}{ocaml}
Sqrt t    -> (wf_term t) && (interp t >=. 0.)
	\end{minted}

	\paragraph{21. compute} L'implémentation de cette fonction est facile puisqu'il suffit d'appeler les fonctions
	définies précedemment pour chaque cas. Il faut simplment faire attention à cacluler récursivement les sous-termes
	à la bonne précision (selon l'opération à réaliser). La preuve se fait automatiquement, il faut juste préciser le variant.
	\begin{minted}{ocaml}
let rec compute (t:term) (n:int) : int
	requires { wf_term t }
	ensures { framing (interp t) result n }
	variant { t }
	=
	match t with
	| Cst c     -> compute_cst n c
	| Add t1 t2 -> compute_add n (interp t1) (compute t1 (n+1)) (interp t2) (compute t2 (n+1))
	| Neg t     -> compute_neg n (interp t)  (compute t n)
	| Sub t1 t2 -> compute_sub n (interp t1) (compute t1 (n+1)) (interp t2) (compute t2 (n+1))
	| Sqrt t    -> compute_sqrt n (interp t) (compute t (2*n))
	end
	\end{minted}

	\section{Conclusion}
		
	\begin{enumerate}
		\item Lemmes en dehors des fonctions: plus efficace pour prouver des résultats mathématiques indépendants.
	\end{enumerate}

\end{document}